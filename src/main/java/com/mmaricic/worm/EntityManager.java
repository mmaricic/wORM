package com.mmaricic.worm;

import com.mmaricic.worm.exceptions.EntityException;
import com.mmaricic.worm.exceptions.EntityIdException;
import com.mmaricic.worm.exceptions.EntityIdException.EntityIdExceptionType;
import com.mmaricic.worm.exceptions.QueryException;
import org.apache.commons.dbcp2.BasicDataSource;

import java.lang.reflect.Field;
import java.sql.*;
import java.util.*;

public class EntityManager {
    private final BasicDataSource dbSource;
    private final EntityParser entityParser;
    private final AnnotationHandler annotationHandler;

    public EntityManager(BasicDataSource dbSource) {
        this.dbSource = dbSource;
        entityParser = new EntityParser();
        annotationHandler = new AnnotationHandler(this);
    }

    public boolean save(Object entity) throws EntityException {
        return save(entity, null);
    }

    boolean save(Object entity, Map<String, Object> parentsIds) {
        if (entity == null)
            return false;
        if (parentsIds == null) {
            parentsIds = new LinkedHashMap<>();
        }
        parentsIds.putAll(annotationHandler.getAssociatedParentsIds(entity));

        String tableName = entityParser.extactTableName(entity.getClass());
        boolean autogeneratedId = entityParser.idIsAutoGenerated(entity.getClass());
        Map<String, Object> entityElements = entityParser.parse(entity, !autogeneratedId);
        entityElements.putAll(parentsIds);

        String sql = QueryBuilder.buildInsertQuery(tableName, entityElements);
        AbstractMap.SimpleEntry<String, Object> entityId = entityParser.extractId(entity); // Ovo bi trebalo da bude mapa vrednosti

        if (autogeneratedId && entityId.getValue() != null) {
            throw new EntityIdException(entity.getClass().getSimpleName(), EntityIdExceptionType.AUTO_GENERATED_ID);
        }
        if (!autogeneratedId && entityId.getValue() == null) {
            throw new EntityIdException(entity.getClass().getSimpleName(), EntityIdExceptionType.MISSING_ID_VALUE);
        }

        try (Connection conn = dbSource.getConnection();
             Statement stm = conn.createStatement()) {
            int res = stm.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
            if (!autogeneratedId)
                return res != 0;

            ResultSet generatedKeys = stm.getGeneratedKeys();
            if (generatedKeys.next()) {
                Field idField = entity.getClass().getDeclaredField(entityId.getKey());
                idField.setAccessible(true);
                idField.set(entity, getValue(generatedKeys, idField.getType()));

                return annotationHandler.saveAssociations(entity);
            } else
                return false;

        } catch (SQLException e) {
            throw new QueryException(
                    String.format("An error occurred while trying to save an entity of class %s. Error: %s",
                            entity.getClass().getSimpleName(), e.getMessage()));
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new EntityException(String.format(
                    "An error occured while trying to set auto-generated ID for object type class %s. Error: %s",
                    entity.getClass().getSimpleName(), e.getMessage()));
        }
    }

    private Object getValue(ResultSet generatedKeys, Class<?> type) throws SQLException {
        if (type.isAssignableFrom(Integer.class))
            return generatedKeys.getInt(1);
        if (type.isAssignableFrom(Long.class))
            return generatedKeys.getLong(1);


        return generatedKeys.getObject(1);
    }

    public boolean delete(Object entity) {
        if (entity == null)
            return false;
        annotationHandler.deleteAssociations(entity);
        String tableName = entityParser.extactTableName(entity.getClass());
        AbstractMap.SimpleEntry<String, Object> id = entityParser.extractId(entity);
        String sql = QueryBuilder.buildDeleteQuery(tableName, id.getKey(), id.getValue());
        try (Connection conn = dbSource.getConnection();
             Statement stm = conn.createStatement()) {
            int res = stm.executeUpdate(sql);
            return res != 0;
        } catch (SQLException e) {
            throw new QueryException(
                    String.format("An error occurred while trying to delete an entity of class %s. Error: %s",
                            entity.getClass().getSimpleName(), e.getMessage()));
        }
    }

    public boolean update(Object entity) {
        return update(entity, null);
    }

    boolean update(Object entity, Map<String, Object> parentIds) {
        if (entity == null)
            return false;
        if (parentIds == null) {
            parentIds = new LinkedHashMap<>();
        }
        parentIds.putAll(annotationHandler.getAssociatedParentsIds(entity));
        String tableName = entityParser.extactTableName(entity.getClass());
        AbstractMap.SimpleEntry<String, Object> id = entityParser.extractId(entity);
        Map<String, Object> entityElements = entityParser.parse(entity, false);
        entityElements.putAll(parentIds);

        String sql = QueryBuilder.buildUpdateQuery(tableName, entityElements, id.getKey(), id.getValue());
        try (Connection conn = dbSource.getConnection();
             Statement stm = conn.createStatement()) {
            int res = stm.executeUpdate(sql);
            if (res == 0)
                return false;
            return annotationHandler.saveAssociations(entity);
        } catch (SQLException e) {
            throw new QueryException(
                    String.format("An error occurred while trying to update an entity of class %s. Error: %s",
                            entity.getClass().getSimpleName(), e.getMessage()));
        }
    }

    public <T> T find(Class<T> entityClass, Object id) {
        String idColumn = entityParser.extractIdColumnName(entityClass);
        String tableName = entityParser.extactTableName(entityClass);
        String sql = QueryBuilder.buildFindByIdQuery(tableName, idColumn, id);

        try (Connection conn = dbSource.getConnection();
             Statement stm = conn.createStatement()) {
            ResultSet resultSet = stm.executeQuery(sql);
            List<T> result = convertResultSetToEntity(resultSet, entityClass);

            if (result.size() > 0)
                return result.get(0);
        } catch (SQLException e) {
            throw new QueryException(String.format(
                    "An error occurred while searching for an entity of class: %s with an id: %s. Error: %s",
                    entityClass.getSimpleName(), id.toString(), e.getMessage()));
        }
        return null;


    }

    private <T> List<T> convertResultSetToEntity(ResultSet resultSet, Class<T> entityClass) throws SQLException {
        List<T> result = new ArrayList<>();
        while (resultSet.next()) {
            Map<String, Object> entityElements = convertRowToMap(resultSet);
            result.add(entityParser.convertRowToEntity(entityClass, entityElements, null));
        }
        return result;
    }


    private Map<String, Object> convertRowToMap(ResultSet resultSet) throws SQLException {
        ResultSetMetaData meta = resultSet.getMetaData();
        int colCount = meta.getColumnCount();
        Map<String, Object> mappedRow = new HashMap<>();
        for (int i = 1; i <= colCount; i++) {
            String colName = meta.getColumnLabel(i);
            Object colValue = resultSet.getObject(i);
            mappedRow.put(colName, colValue);
        }
        return mappedRow;
    }

    public <T> LazyList<T> find(Class<T> entityClass) {
        String tableName = entityParser.extactTableName(entityClass);
        String sql = QueryBuilder.buildFindQuery(tableName);
        return new LazyList<>(sql, entityClass, this);
    }

    public List<Map<String, Object>> query(String sql) {
        try (Connection conn = dbSource.getConnection();
             Statement stm = conn.createStatement()) {
            ResultSet resultSet = stm.executeQuery(sql);

            List<Map<String, Object>> result = new ArrayList<>();
            while (resultSet.next()) {
                result.add(convertRowToMap(resultSet));
            }
            return result;
        } catch (SQLException e) {
            throw new QueryException(String.format("An error occurred while executing query:'%s'. Error: %s",
                    sql, e.getMessage()));
        }
    }

    int executeUpdate(String sql) {
        try (Connection conn = dbSource.getConnection();
             Statement stm = conn.createStatement()) {
            return stm.executeUpdate(sql);
        } catch (SQLException e) {
            throw new QueryException(String.format("An error occurred while executing query:'%s'. Error: %s",
                    sql, e.getMessage()));
        }
    }
}
